"""A HTTP state transaction."""
import sys

class HttpTransaction(object):
    """A HTTP transaction object.

    This mirrors the whole state of a HTTP request and response. Its more like
    a container holding a whole HTTP transaction. For each request there is a
    equivalent response. This object is intended to be generated by the HTTP
    parser.

    Example usage:
    >>> from dragonbelly.http import HttpTransaction
    >>> conn = HttpTransaction()
    >>> conn.method(conn.GET)
    >>> conn.path('/upload/test.jpg')
    >>> conn.path()
    '/upload/test.jpg'
    >>> conn.method()
    'GET'
    >>> conn.response()
    ''
    >>> conn.status()
    200
    """
    GET = 'GET'
    POST = 'POST'

    def __init__(self, method=None, path=None, host=None, status='200'):
        self.request = Request()   # The original HTTP request.
        self.response = Response() # The generated HTTP response.

        self.request['method'] = method
        self.request['path'] = path
        self.request['host'] = host

    def __repr__(self):
        return '<HTTP transaction:\n method: %s' % [self._method if self._method else 'NOT SET']

class HTTPRequest(object):
    """A HTTP request object.
    
    >>> import http
    >>> h = http.HttpRequest(path='/upload/test.jpg')
    >>> h['path']
    '/upload/test.jpg'
    >>> h['method']
    >>> h['unknown_key']
    Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
            File "http.py", line 67, in __getitem__
                return self._header[header.lower()]
            KeyError: 'unknown_key'
    """
    def __init__(self, **kwargs):
        self._header = {
            'method': None,
            'path': None,
            'version': None,
            'host': None,
        }
        for key in kwargs:
            try:
                self._header[key] = kwargs[key]
            except KeyError as e:
                raise

    def __setitem__(self, header, value):
        self._header[header.lower()] = str(value)

    def __getitem__(self, header):
        return self._header[header.lower()]

    def __delitem__(self, header):
        try:
            del self._header[header.lower()]
        except KeyError as e:
            print(e)
            raise

class HTTPResponse(object):
    """A HTTP response object.
    
    >>> import http
    >>> h = http.HttpResponse(content='H')
    >>> for i in h:
    ...     print(i)
    ... 
    H
    """
    def __init__(self, content='', **kwargs):
        self._header = {}
        self._header['status_code'] = 200
        self._content = content

        for key in kwargs:
            self._header[key] = kwargs[key]

    def __setitem__(self, header, value):
        self._header[header.lower()] = str(value)

    def __getitem__(self, header):
        return self._header[header.lower()]

    def __delitem__(self, header):
        try:
            del self._header[header.lower()]
        except KeyError as e:
            print(e)
            raise

    def __iter__(self):
        self._iterator = iter(self._content)
        return self._iterator

    def next(self):
        chunk = self._iterator.next()
        return str(chunk)

class HTTPParser(object):
    """Parses a HTTP incoming request into a HttpRequest() object."""
    # Table mapping response codes to messages; entries have the
    # form {code: (shortmessage, longmessage)}.
    # See RFC 2616.
    responses = {
        100: ('Continue', 'Request received, please continue'),
        101: ('Switching Protocols',
              'Switching to new protocol; obey Upgrade header'),

        200: ('OK', 'Request fulfilled, document follows'),
        201: ('Created', 'Document created, URL follows'),
        202: ('Accepted',
              'Request accepted, processing continues off-line'),
        203: ('Non-Authoritative Information', 'Request fulfilled from cache'),
        204: ('No Content', 'Request fulfilled, nothing follows'),
        205: ('Reset Content', 'Clear input form for further input.'),
        206: ('Partial Content', 'Partial content follows.'),

        300: ('Multiple Choices',
              'Object has several resources -- see URI list'),
        301: ('Moved Permanently', 'Object moved permanently -- see URI list'),
        302: ('Found', 'Object moved temporarily -- see URI list'),
        303: ('See Other', 'Object moved -- see Method and URL list'),
        304: ('Not Modified',
              'Document has not changed since given time'),
        305: ('Use Proxy',
              'You must use proxy specified in Location to access this '
              'resource.'),
        307: ('Temporary Redirect',
              'Object moved temporarily -- see URI list'),

        400: ('Bad Request',
              'Bad request syntax or unsupported method'),
        401: ('Unauthorized',
              'No permission -- see authorization schemes'),
        402: ('Payment Required',
              'No payment -- see charging schemes'),
        403: ('Forbidden',
              'Request forbidden -- authorization will not help'),
        404: ('Not Found', 'Nothing matches the given URI'),
        405: ('Method Not Allowed',
              'Specified method is invalid for this server.'),
        406: ('Not Acceptable', 'URI not available in preferred format.'),
        407: ('Proxy Authentication Required', 'You must authenticate with '
              'this proxy before proceeding.'),
        408: ('Request Timeout', 'Request timed out; try again later.'),
        409: ('Conflict', 'Request conflict.'),
        410: ('Gone',
              'URI no longer exists and has been permanently removed.'),
        411: ('Length Required', 'Client must specify Content-Length.'),
        412: ('Precondition Failed', 'Precondition in headers is false.'),
        413: ('Request Entity Too Large', 'Entity is too large.'),
        414: ('Request-URI Too Long', 'URI is too long.'),
        415: ('Unsupported Media Type', 'Entity body in unsupported format.'),
        416: ('Requested Range Not Satisfiable',
              'Cannot satisfy request range.'),
        417: ('Expectation Failed',
              'Expect condition could not be satisfied.'),

        500: ('Internal Server Error', 'Server got itself in trouble'),
        501: ('Not Implemented',
              'Server does not support this operation'),
        502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),
        503: ('Service Unavailable',
              'The server cannot process the request due to a high load'),
        504: ('Gateway Timeout',
              'The gateway server did not receive a timely response'),
        505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),
    }

    def __init__(self, request=None):
        if request:
            self._raw_request = request
            return self.parse(request=self._raw_request)
        self._raw_request = None

    def parse(self, **kwargs):
        """Parse a request.

        The request is stored into a HttpRequest() object and returned. The
        can be accesed as dictionary.

        Return a dictionary object for success and False for failure.
        """
        if kwargs['request']:
            self._raw_request = kwargs['request']
        if not kwargs['request'] and not self._raw_request:
            return False
        self.command = None  # set in case of error on the first line
        self.request_version = 'HTTP/1.1' #version = self.default_request_version
        self.close_connection = 1
        requestline = str(self._raw_request)
        if requestline[-2:] == '\r\n':
            requestline = requestline[:-2]
        elif requestline[-1:] == '\n':
            requestline = requestline[:-1]
        self.requestline = requestline
        words = requestline.split()
        if len(words) == 3:
            [command, path, version] = words
            if version[:5] != 'HTTP/':
                self.send_error(400, "Bad request version (%r)" % version)
                return False
            try:
                base_version_number = version.split('/', 1)[1]
                version_number = base_version_number.split(".")
                # RFC 2145 section 3.1 says there can be only one "." and
                #   - major and minor numbers MUST be treated as
                #      separate integers;
                #   - HTTP/2.4 is a lower version than HTTP/2.13, which in
                #      turn is lower than HTTP/12.3;
                #   - Leading zeros MUST be ignored by recipients.
                if len(version_number) != 2:
                    raise ValueError
                version_number = int(version_number[0]), int(version_number[1])
            except (ValueError, IndexError):
                self.send_error(400, "Bad request version (%r)" % version)
                return False
            if version_number >= (1, 1) and self.protocol_version >= "HTTP/1.1":
                self.close_connection = 0
            if version_number >= (2, 0):
                self.send_error(505,
                          "Invalid HTTP Version (%s)" % base_version_number)
                return False
        elif len(words) == 2:
            [command, path] = words
            self.close_connection = 1
            if command != 'GET':
                self.send_error(400,
                                "Bad HTTP/0.9 request type (%r)" % command)
                return False
        elif not words:
            return False
        else:
            self.send_error(400, "Bad request syntax (%r)" % requestline)
            return False
        #self.command, self.path, self.request_version = command, path, version
        return HTTPRequest(method=command, path=path, version=version)

    def send_error(self, code, message=None):
        """Send and log an error reply.

        Arguments are the error code, and a detailed message.
        The detailed message defaults to the short entry matching the
        response code.

        This sends an error response (so it must be called before any
        output has been generated), logs the error, and finally sends
        a piece of HTML explaining the error to the user.

        """

        try:
            shortmsg, longmsg = self.responses[code]
        except KeyError:
            shortmsg, longmsg = '???', '???'
        if message is None:
            message = shortmsg
        explain = longmsg
        self.log_error("code %d, message %s", code, message)
        # using _quote_html to prevent Cross Site Scripting attacks (see bug #1100201)
        content = (self.error_message_format %
                   {'code': code, 'message': _quote_html(message), 'explain': explain})
        self.send_response(code, message)
        self.send_header("Content-Type", self.error_content_type)
        self.send_header('Connection', 'close')
        self.end_headers()
        if self.command != 'HEAD' and code >= 200 and code not in (204, 304):
            self.wfile.write(content.encode('UTF-8', 'replace'))

    def log_request(self, code='-', size='-'):
        """Log an accepted request.

        This is called by send_response().

        """

        self.log_message('"%s" %s %s',
                         self.requestline, str(code), str(size))

    def log_error(self, format, *args):
        """Log an error.

        This is called when a request cannot be fulfilled.  By
        default it passes the message on to log_message().

        Arguments are the same as for log_message().

        XXX This should go to the separate error log.

        """

        self.log_message(format, *args)

    def log_message(self, format, *args):
        """Log an arbitrary message.

        This is used by all other logging functions.  Override
        it if you have specific logging wishes.

        The first argument, FORMAT, is a format string for the
        message to be logged.  If the format string contains
        any % escapes requiring parameters, they should be
        specified as subsequent arguments (it's just like
        printf!).

        The client host and current date/time are prefixed to
        every message.

        """

        sys.stderr.write("%s - - [%s] %s\n" %
                         (self.address_string(),
                          self.log_date_time_string(),
                          format%args))
